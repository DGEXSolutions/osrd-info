<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OSRD – Module de recherche de sillons</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/</link><description>Recent content in Module de recherche de sillons on OSRD</description><generator>Hugo -- gohugo.io</generator><language>fr</language><atom:link href="https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Parcours de l'infrastructure</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/</guid><description>
&lt;p>La première chose à définir est &lt;em>comment un train se déplace sur l&amp;rsquo;infrastructure&lt;/em>,
sans prendre en compte les conflits pour l&amp;rsquo;instant.&lt;/p>
&lt;p>On a besoin d&amp;rsquo;une manière de définir et d&amp;rsquo;énumérer les différents chemins
possibles et de parcourir l&amp;rsquo;infrastructure, avec plusieurs contraintes :&lt;/p>
&lt;ol>
&lt;li>Le chemin doit être compatible avec le matériel roulant donné
(électrification, gabarit, systèmes de signalisation)&lt;/li>
&lt;li>À n&amp;rsquo;importe quel point, on doit être en mesure d&amp;rsquo;accéder aux propriétés
du chemin depuis le point de départ jusqu&amp;rsquo;au point considéré.
Cela inclus les routes et les cantons.&lt;/li>
&lt;li>Dans certains cas, on doit savoir où le train ira &lt;em>après&lt;/em>
le point actuellement évalué (pour une détection de conflits correcte).&lt;/li>
&lt;/ol>
&lt;p>Pour répondre à ce besoin, une classe &lt;code>InfraExplorer&lt;/code> a été implémentée.
Elle utilise les cantons (section de signal en signal) comme subdivision
principale.
Elle est composée de 3 sections : le canton courant, les prédécesseurs,
et les cantons suivants.&lt;/p>
&lt;p>&lt;img src="infra_explorer.svg" alt="InfraExplorer structure">&lt;/p>
&lt;p>Dans cet exemple, les flèches vertes sont les cantons précédents.
Ce qui se produit dessus est considéré comme immuable.&lt;/p>
&lt;p>La flèche rouge est le canton actuellement exploré.
C&amp;rsquo;est à cet endroit que les simulations du train et de la
signalisation sont effectuées, et que les conflits
sont évités.&lt;/p>
&lt;p>Les flèches bleues sont les cantons suivants. Cette section
n&amp;rsquo;est pas encore simulée, elle existe seulement pour savoir
où le train ira ensuite. Dans cet exemple, elle indique
que le signal en bas à droite peut être ignoré, seul
le chemin du haut sera utilisé.
Le chemin du bas sera évalué dans une autre instance de
&lt;code>InfraExplorer&lt;/code>.&lt;/p>
&lt;p>Plus de détails sur la classe et son interface sont
présents sur la version anglaise de la page.&lt;/p></description></item><item><title>Docs: Détection de conflits</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_detection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_detection/</guid><description>
&lt;p>Maintenant qu&amp;rsquo;on sait quels chemins peuvent être utilisés,
on doit déterminer à quel moment ces chemins sont libres.&lt;/p>
&lt;p>La documentation (en anglais seulement)
de la détection de conflits explique comment elle est réalisée
en interne. Pour résumer, un train est en conflit avec un autre
quand il observe un signal lui indiquant de ralentir.
Dans notre cas, une solution où cette situation se produit
est considérée comme invalide, le train doit arriver
au signal donné plus tard (ou plus tôt) quand le signal
n&amp;rsquo;est plus contraignant.&lt;/p>
&lt;p>Cependant, la détection de conflit doit être réalisée de
manière &lt;em>incrémentale&lt;/em>, ce qui veut dire que :&lt;/p>
&lt;ol>
&lt;li>Quand une simulation est effectuée jusqu&amp;rsquo;à t=x, tous les conflits
qui arrivent avant t=x doivent être connus, &lt;em>même s&amp;rsquo;ils sont
indirectement provoqués par un signal vu à t &amp;gt; x&lt;/em> plus loin sur le chemin.&lt;/li>
&lt;li>Les conflits et utilisations de ressources doivent être identifiés
dès qu&amp;rsquo;ils se produisent, même si le temps de fin d&amp;rsquo;utilisation n&amp;rsquo;est
pas encore défini.&lt;/li>
&lt;/ol>
&lt;p>Pour que ce soit possible, on doit être en mesure de savoir où
le train ira &lt;em>après&lt;/em> la section actuellement simulée (cf
&lt;a href="https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/infrastructure_exploration/" title="exploration de l'infrastructure">exploration de l&amp;rsquo;infrastructure&lt;/a>
)&lt;/p>
&lt;p>Pour gérer ce cas, le module de détection de conflit
peut renvoyer une erreur quand il est nécessaire d&amp;rsquo;avoir
plus d&amp;rsquo;information sur la suite du chemin. Quand ce cas
se produit, les objets &lt;code>InfraExplorer&lt;/code> sont clonés
pour étendre les chemins.&lt;/p></description></item><item><title>Docs: Représentation de l'espace de solutions</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/graph_representation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/graph_representation/</guid><description>
&lt;h4 id="principe-général">Principe général&lt;/h4>
&lt;p>Le problème reste une recherche de graphe. En représentant
l&amp;rsquo;espace de solution sous forme de graphe, il est possible de réutiliser
nos outils déjà existants de recherche de chemin.&lt;/p>
&lt;p>Le &lt;em>graphe produit&lt;/em> de la position, du temps, et de la vitesse est utilisé.
Autrement dit, chaque élément du graphe contient (entre autres) ces
3 variables.&lt;/p>
&lt;p>Chaque arête du graphe est calculée avec un
&lt;a href="https://osrd.fr/fr/docs/explanation/running_time_calculation/" title="calcul de marche">calcul de marche&lt;/a>
pour connaître l&amp;rsquo;évolution de la vitesse et de la position dans le temps.&lt;/p>
&lt;h4 id="représentation-visuelle">Représentation visuelle&lt;/h4>
&lt;p>Le graphe de départ représente l&amp;rsquo;infrastructure physique&lt;/p>
&lt;p>&lt;img src="routes_time_1.png" alt="Graphe produit (1/3)">&lt;/p>
&lt;p>Il est ensuite &amp;ldquo;dupliqué&amp;rdquo; à des temps différents&lt;/p>
&lt;p>&lt;img src="routes_time_2.png" alt="Graphe produit (2/3)">&lt;/p>
&lt;p>Puis des nœuds sont reliés de manière à refléter le temps de parcours&lt;/p>
&lt;p>&lt;img src="routes_time_3.png" alt="Graphe produit (3/3)">&lt;/p>
&lt;h4 id="précisions">Précisions&lt;/h4>
&lt;ul>
&lt;li>Le graphe est construit &lt;em>au fil de l&amp;rsquo;exploration&lt;/em>.&lt;/li>
&lt;li>Une discrétisation est faite au niveau du temps, uniquement pour
évaluer ce qui a déjà été visité. Si le même emplacement est visité une
seconde fois, il faut une certaine différence de temps pour estimer
qu&amp;rsquo;il n&amp;rsquo;est pas déjà visité.&lt;/li>
&lt;li>Toutes les arêtes sont réalisées avec des calculs de marche&lt;/li>
&lt;li>La vitesse n&amp;rsquo;est pas discrétisée ni utilisée pour estimer quel
emplacement est déjà visité, mais elle fait partie des calculs.&lt;/li>
&lt;li>Par défaut, tous les calculs sont faits en allant à la vitesse maximale.
Les ralentissements sont ajoutés seulement quand ils sont nécessaires.&lt;/li>
&lt;/ul>
&lt;h4 id="exemple">Exemple&lt;/h4>
&lt;p>Par exemple, avec l&amp;rsquo;infrastructure suivante en se basant sur
le graphe des voies :
&lt;img src="example_infra.svg" alt="Infra d&amp;rsquo;exemple">&lt;/p>
&lt;p>Explorer le graphe des sillons possibles peut donner ce
type de résultat :
&lt;img src="example_graph.svg" alt="Représentation du graphe">&lt;/p></description></item><item><title>Docs: Discontinuités et retours en arrière</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/backtracking/</guid><description>
&lt;h4 id="le-problème-des-discontinuités">Le problème des discontinuités&lt;/h4>
&lt;p>Au moment d&amp;rsquo;explorer une arête du graphe, on effectue un calcul de
marche pour connaître l&amp;rsquo;évolution de la vitesse.
Mais il n&amp;rsquo;est pas possible de voir plus loin que l&amp;rsquo;arête en question,
ce qui est gênant pour calculer les courbes de freinages qui peuvent
nécessiter de commencer à freiner plusieurs kilomètres avant l&amp;rsquo;arrivée.&lt;/p>
&lt;p>&lt;img src="discontinuity.png" alt="Discontinuité">&lt;/p>
&lt;blockquote>
&lt;p>Cet exemple illustre le problème : par défaut
la première arête est explorée en allant à la vitesse maximale.
C&amp;rsquo;est seulement en explorant la seconde arête que la destination devient visible,
sans que la distance restante soit suffisante pour s&amp;rsquo;arrêter.&lt;/p>
&lt;/blockquote>
&lt;h4 id="la-solution--revenir-en-arrière">La solution : revenir en arrière&lt;/h4>
&lt;p>Pour régler ce problème, lorsqu&amp;rsquo;une arête est générée avec une discontinuité
dans les courbes de vitesse, l&amp;rsquo;algorithme revient sur les arêtes précédentes
pour en créer des nouvelles qui incluent les décélérations.&lt;/p>
&lt;p>Pour donner un exemple simplifié, sur un chemin de 4 routes
où le train peut accélérer ou décélérer de 10km/h par route :&lt;/p>
&lt;p>&lt;img src="backtracking_1.png" alt="Discontinuité (version arêtes, 1/2)">&lt;/p>
&lt;p>Pour que le train s&amp;rsquo;arrête à la fin de la route 4, il doit être au plus à 10km/h
à la fin de la route 3. Une nouvelle arête est alors créée sur la route
3 qui finit à 10km/h. Une décélération est ensuite calculée à rebours de la fin de la route
vers le début, jusqu&amp;rsquo;à retrouver la courbe d&amp;rsquo;origine (ou le début
de l&amp;rsquo;arrête).&lt;/p>
&lt;p>Dans cet exemple, la discontinuité a seulement été déplacée vers la
transition entre les routes 2 et 3. Le procédé est ensuite réitéré
sur la route 2, ce qui donne le résultat suivant :&lt;/p>
&lt;p>&lt;img src="backtracking_2.png" alt="Discontinuité (version arêtes, 2/2)">&lt;/p>
&lt;p>Les anciennes arêtes sont toujours présentes dans le graphe, elles
peuvent mener à d&amp;rsquo;autres solutions.&lt;/p></description></item><item><title>Docs: Contourner les conflits</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_avoidance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/conflict_avoidance/</guid><description>
&lt;p>En explorant le graphe, il arrive souvent de tomber sur des situations
qui mèneraient à des conflits. Il faut être en mesure de rajouter du délai
pour les éviter.&lt;/p>
&lt;h4 id="décalage-du-temps-de-départ">Décalage du temps de départ&lt;/h4>
&lt;p>Dans les paramètres de l&amp;rsquo;algorithme, le temps de départ est donné
sous la forme d&amp;rsquo;une fenêtre : un temps de départ au plus tôt et au plus tard.
Tant que c&amp;rsquo;est possible, il est toujours préférable de décaler le temps
de départ pour éviter les conflits.&lt;/p>
&lt;blockquote>
&lt;p>Par exemple : un train doit partir entre 10:00 et 11:00. En partant
à 10:00, cela provoque un conflit, le train doit entrer en gare
d&amp;rsquo;arrivée 15 minutes plus tard. Il suffit de faire partir le train à
10:15 pour régler le problème.&lt;/p>
&lt;/blockquote>
&lt;p>Dans OSRD, cette fonctionnalité est gérée en gardant une trace,
à chaque arête, du décalage maximal du temps de départ qui pourra
être ajouté sur la suite du parcours. Tant que cette valeur est suffisante,
tous les conflits sont évités par ce moyen.&lt;/p>
&lt;p>Le décalage du temps de départ est une valeur stockée sur chaque arête
et additionnée à la fin de la recherche de chemin.&lt;/p>
&lt;blockquote>
&lt;p>Par exemple :&lt;/p>
&lt;ul>
&lt;li>un train doit partir entre 10:00 et 11:00. La recherche
commence avec un délai maximal de 1:00.&lt;/li>
&lt;li>Après quelques arêtes, une non-disponibilité est constatée
20 minutes après notre passage. La valeur passe donc à
20 minutes pour la suite du parcours.&lt;/li>
&lt;li>Le temps de départ est ensuite décalé de 5 minutes pour contourner
un conflit, modifiant le décalage maximal à 15 minutes.&lt;/li>
&lt;li>Ce procédé continue jusqu&amp;rsquo;à arriver à la fin du trajet, ou
jusqu&amp;rsquo;au point où il faut ajouter plus de délai.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="marges-de-construction">Marges de construction&lt;/h4>
&lt;p>Quand la valeur de décalage maximal du temps de départ tombe à 0,
il faut rajouter du délai entre deux points du parcours du train.&lt;/p>
&lt;p>&lt;img src="engineering_allowance.png" alt="Marge de construction (1/2)">&lt;/p>
&lt;p>Le principe est le même que pour régler les discontinuités de vitesse :
le graphe est parcouru en arrière pour créer de nouvelles arêtes.&lt;/p>
&lt;p>&lt;img src="engineering_allowance_edges.png" alt="Marge de construction (2/2)">&lt;/p>
&lt;p>La &lt;a href="https://osrd.fr/fr/docs/explanation/running_time_calculation/allowances/" title="marges">marge de construction&lt;/a>
est une fonctionnalité du calcul de marche
permettant d&amp;rsquo;ajouter un délai donné entre deux points du parcours.&lt;/p>
&lt;h2 id="post-processing">Post-processing&lt;/h2>
&lt;p>Les marges de constructions &lt;em>étaient&lt;/em> calculées pendant
l&amp;rsquo;exploration du graph, mais ce procédé était trop
couteux en temps de calcul. On effectuait des dichotomies
sur des simulations qui pouvaient s&amp;rsquo;étendre sur des
portions importantes du chemin.&lt;/p>
&lt;p>On a seulement besoin de savoir si la marge de construction
&lt;em>peut&lt;/em> être réalisée sans provoquer de conflit.
Des heuristiques peuvent être utilisées ici tant qu&amp;rsquo;on est
plus restrictif que permissif : une marge impossible
doit être identifiée comme telle, mais manquer une solution
avec une marge extrêmement serrée n&amp;rsquo;est pas une mauvaise chose.&lt;/p>
&lt;p>Mais avec ce changement, une fois qu&amp;rsquo;une solution est trouvée,
il ne suffit plus de concaténer les résultats de simulation
pour obtenir la simulation finale. On doit réaliser une
simulation complète avec les vraies marges de construction
qui évitent tout conflit. Cette étape se rejoint avec celle
décrite pour les
&lt;a href="https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/" title="marges de régularité">marges de régularité&lt;/a>,
qui est maintenant réalisée même sans marge de régularité
spécifiée.&lt;/p></description></item><item><title>Docs: Marge de régularité</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/standard_allowance/</guid><description>
&lt;p>Une des fonctionnalités qui doit être supportée par STDCM est la
&lt;a href="https://osrd.fr/fr/docs/explanation/running_time_calculation/allowances/" title="marge de régularité">marge de régularité&lt;/a>.
L&amp;rsquo;utilisateur doit pouvoir indiquer une valeur
de marge, exprimée en fonction de la distance ou du temps de parcours,
et cette marge doit être ajoutée au trajet.&lt;/p>
&lt;blockquote>
&lt;p>Par exemple : l&amp;rsquo;utilisateur peut indiquer une marge de 5 minutes au
100km. Sur un trajet de 42km, un trajet de 10 minutes au plus rapide
doit maintenant durer 12 minutes et 6 secondes.&lt;/p>
&lt;/blockquote>
&lt;p>Le problème se situe au niveau de la détection de conflits.
En effet, ralentir le train décale l&amp;rsquo;ensemble du sillon dans le temps
et augmente la capacité consommée.
La marge doit donc être prise en compte pendant l&amp;rsquo;exploration
pour détecter correctement les conflits.&lt;/p>
&lt;p>Pour plus de difficulté, la marge doit suivre le modèle
&lt;a href="https://osrd.fr/pdf/MARECO.pdf">MARECO&lt;/a>.
La marge n&amp;rsquo;est pas répartie uniformément sur le trajet, mais selon
un calcul qui nécessite de connaître l&amp;rsquo;ensemble du trajet.&lt;/p>
&lt;h3 id="pendant-lexploration">Pendant l&amp;rsquo;exploration&lt;/h3>
&lt;p>La principale implication de la marge de régularité est pendant
l&amp;rsquo;exploration du graphe, quand on identifie les conflits.
Les temps et les vitesses doivent être baissés linéairement
pour prendre en compte les conflits au bon moment.
La simulation au plus rapide doit tout de même être calculée
car elle peut définir le temp supplémentaire.&lt;/p>
&lt;p>Ce procédé &lt;em>n&amp;rsquo;est pas exact&lt;/em> car il ignore la manière dont
la marge est appliquée (en particulier pour MARECO).
Mais à cette étape les temps exacts ne sont pas nécessaires,
il est seulement nécessaire de savoir si une solution existe
à ce temps approximatif.&lt;/p>
&lt;div class="alert alert-info" role="alert">
Ce procédé inexact peut sembler être un problème, mais en
pratique (pour la SNCF) les marges de régularités ont en
fait une tolérance entre deux points arbitraires
du chemin. Par exemple pour une marge indiquée à 5 minutes
par 100km, une solution avec la marge entre 3 et 7 minutes
entre deux PR serait acceptable. Cette tolérance ne sera
pas encodée explicitement, mais elle
permet de faire des approximations de quelques
secondes pendant la recherche.
&lt;/div>
&lt;h4 id="post-processing">Post-processing&lt;/h4>
&lt;p>Une fois que le chemin est trouvé, il est nécessaire
de faire une simulation finale pour appliquer correctement
les marges. Le procédé est le suivant :&lt;/p>
&lt;ol>
&lt;li>Pour certains points du chemin, le temps est fixé.
C&amp;rsquo;est un paramètre d&amp;rsquo;entrée de la simulation qui appelle
le module de marge. À l&amp;rsquo;initialisation, le temps est fixé
à chaque point d&amp;rsquo;arrêt.&lt;/li>
&lt;li>Une simulation est réalisée. En cas de conflit, on
s&amp;rsquo;intéresse au premier&lt;/li>
&lt;li>Un point est fixé à la position de ce conflit.
Le temps de référence est celui considéré pendant l&amp;rsquo;exploration.&lt;/li>
&lt;li>Ce procédé est répété itérativement jusqu&amp;rsquo;à une absence de conflit&lt;/li>
&lt;/ol></description></item><item><title>Docs: Détails d'implémentation</title><link>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/implementation_details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://osrd.fr/fr/docs/reference/design-docs/stdcm/pathfinding_module/implementation_details/</guid><description>
&lt;p>Cette page précise certains détails d&amp;rsquo;implémentation.
Sa lecture n&amp;rsquo;est pas nécessaire pour comprendre les principes
généraux, mais peut aider avant de se plonger dans le code.&lt;/p>
&lt;h4 id="stdcmedgebuilder">STDCMEdgeBuilder&lt;/h4>
&lt;p>Cette classe est utilisée pour simplifier la création d&amp;rsquo;instances de &lt;code>STDCMEdge&lt;/code>,
les arêtes du graphe. Celles-ci contiennent de nombreux attributs,
la plupart pouvant être déterminés en fonction du contexte (comme
le nœud précédent). La classe &lt;code>STDCMEdgeBuilder&lt;/code> permet de rendre
certains attributs optionnels et en calcule d&amp;rsquo;autres.&lt;/p>
&lt;p>Une fois instancié et paramétré, un &lt;code>EdgeBuilder&lt;/code> a deux méthodes :&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Collection&amp;lt;STDCMEdge&amp;gt; makeAllEdges()&lt;/code> permet de créer toutes
les arêtes possibles dans le contexte donné pour une route donnée.
S&amp;rsquo;il y a plusieurs &amp;ldquo;ouvertures&amp;rdquo; entre des blocks d&amp;rsquo;occupation,
une arête est créée par ouverture. Tous les conflits, leurs
évitements et les attributs associés sont déterminés ici.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>STDCMEdge findEdgeSameNextOccupancy(double timeNextOccupancy)&lt;/code> :
Cette méthode permet d&amp;rsquo;obtenir l&amp;rsquo;arête passant par une certaine
&amp;ldquo;ouverture&amp;rdquo; (quand elle existe), identifiée ici par le temps
de la prochaine occupation sur la route. Elle est utilisée à chaque
fois qu&amp;rsquo;une arête doit être re-créée dans un contexte différent,
comme pour appliquer une marge ou corriger une discontinuité.
Elle appelle la méthode précédente.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="recherche-de-chemin">Recherche de chemin&lt;/h3>
&lt;h4 id="evaluation-des-distances">Evaluation des distances&lt;/h4>
&lt;p>La fonction utilisée pour déterminer la distance (au sens
de la recherche de chemin) détermine quel chemin sera privilégié.
Le chemin obtenu sera toujours le plus court en fonction du critère
donné.&lt;/p>
&lt;p>Ici, deux paramètres sont utilisés : le temps de parcours total
et l&amp;rsquo;heure de départ. Le second a un poids très faible par rapport
au premier, pour sélectionner en priorité le chemin le plus rapide.
Les détails du calcul sont indiqués dans les commentaires des
méthodes concernées.&lt;/p>
&lt;h4 id="heuristiques">Heuristiques&lt;/h4>
&lt;p>L&amp;rsquo;algorithme de recherche de chemin dans le graphe est un A*,
avec une heuristique basée sur les coordonnées géographiques.&lt;/p>
&lt;p>Cependant, la géométrie des infrastructures générées sont arbitraires,
elle ne correspond pas aux distances indiquées sur les voies.
Il est donc possible que, sur ces infrastructures, les chemins
obtenus ne soient pas les plus courts.&lt;/p>
&lt;p>Il est en théorie possible d&amp;rsquo;utiliser cette heuristique pour
déterminer si le chemin en cours d&amp;rsquo;exploration pourra mener à une
solution dont le temps de parcours ne dépasse pas le maximum.
Mais pour la même raison, ajouter ce critère rend STDCM
inutilisable sur les infrastructures générées.
Plus de détails dans
&lt;a href="https://github.com/OpenRailAssociation/osrd/issues/2818">cette issue&lt;/a>.&lt;/p></description></item></channel></rss>